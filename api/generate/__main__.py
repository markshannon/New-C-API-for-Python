
from __future__ import annotations
from types import FunctionType, ModuleType
from enum import Enum
from .support import *

from . import objects, vm, types_and_modules


def func_ptr_name(func):
    return f"{PREFIX}_{func.__name__}_FuncPtr"

def ctype_for_class(cls, namespace):
    if cls is object:
        return REF
    if isinstance(cls, FunctionType):
        return func_ptr_name(cls)
    if isinstance(cls, list):
        return ctype_for_class(cls[0], namespace) + "*"
    if isinstance(cls, str):
        return cls
    if cls is Self:
        return TYPED_REF(namespace)
    if cls is bool:
        return "bool"
    if cls is int:
        return "int"
    if cls is Void:
        return "void"
    if isinstance(cls, CInt):
        return cls.name
    if isinstance(cls, Pointer):
        return ctype_for_class(cls.cls, namespace) + "*"
    return TYPED_REF(cls.__name__)

def get_arg_decl(name, namespace, annotations):
    if name == "self":
        return [TYPED_REF(namespace), "self"]
    cls = annotations.get(name, object)
    if isinstance(cls, list):
        return [f"{ctype_for_class(cls[0], namespace)}", f"{name}[]"]
    else:
        return [f"{ctype_for_class(cls, namespace)}", f"{name}"]

def get_field_decl(name, namespace, annotations):
    if name == "self":
        return [TYPED_REF(namespace), "self"]
    cls = annotations.get(name, object)
    if isinstance(cls, list):
        return f"{ctype_for_class(cls[0], namespace)} *{name}"
    else:
        return f"{ctype_for_class(cls, namespace)} {name}"

def flatten_args(arg_list):
    return [ f"{type} {name}" for (type, name) in arg_list]

def get_result_type(func):
    return func.__annotations__.get("return", object)

def generate_function_pointer(func):
    func_name = func_ptr_name(func)
    arg_names = func.__code__.co_varnames[: func.__code__.co_argcount]
    annotations = func.__annotations__
    arg_decls = [ get_arg_decl(name, None, annotations) for name in arg_names]
    assert not cannot_fail(func)
    result_type = get_result_type(func)
    #assert result_type is object
    all_args = [ CONTEXT ] + flatten_args(arg_decls)
    print(f"typedef {ctype_for_class(result_type, "")} (*{func_name})({', '.join(all_args)});\n")


def generate_api_func(func, namespace):
    if namespace:
        func_name = f"{PREFIX}_{namespace}_{func.__name__}"
    else:
        func_name = f"{PREFIX}_{func.__name__}"
    arg_names = func.__code__.co_varnames[: func.__code__.co_argcount]
    annotations = func.__annotations__
    arg_decls = [ get_arg_decl(name, namespace, annotations) for name in arg_names]
    return_type = get_result_type(func)
    return_arg = None
    if not cannot_fail(func):
        if return_type is Void or return_type is bool:
            return_type = int
        if isinstance(return_type, CInt):
            return_arg = return_type
            return_type = int
    return_type = ctype_for_class(return_type, namespace)
    all_args = [ CONTEXT ] + flatten_args(arg_decls)
    if return_arg is not None:
        all_args.append(ctype_for_class(return_arg, namespace)+"*")
    if func.__doc__:
        print(f"/* {func.__doc__} */")
    print(f"{return_type} {func_name}({', '.join(all_args)});\n")


print("/* This file is generated by gen/__main__.py */\n")

#Helpers
print(f"{REF} {MISSING};")
print(f"{REF} {ERROR};\n")

print(f"{REF} {REF}_Dup({REF} ref);")
print(f"void {REF}_Close({REF} ref);")
print(f"int {REF}_IsValid({REF} ref);\n")
print(f"int {REF}_IsMissing({REF} ref);\n")
print(f"int {REF}_IsError({REF} ref);\n")

def generate_module(mod):
    for name, obj in mod.__dict__.items():
        if name.startswith("_"):
            continue
        if not isinstance(obj, (type, FunctionType)):
            continue
        generate_api(name, obj, "")

def generate_api(name, obj, namespace):
    if "support" in obj.__module__:
        return
    if isinstance(obj, FunctionType):
        if is_function_pointer(obj):
            generate_function_pointer(obj)
        else:
            generate_api_func(obj, namespace)
        return
    if not isinstance(obj, type):
        return
    cls = obj
    print(f"\n/* {name} from {obj.__module__} */\n")
    if issubclass(cls, Enum):
        print(f"typedef enum {namespace}{cls.__name__} {{")
        for item in cls:
            print(f"    {item.name} = {item.value},")
        print(f"}} {namespace}{cls.__name__};")
    elif issubclass(cls, Struct):
        print(f"typedef struct {namespace}{cls.__name__} {{")
        for item_name in cls.__annotations__:
            print(f"    {get_field_decl(item_name, namespace, cls.__annotations__)},")
        print(f"}} {namespace}{cls.__name__};")
    else:
        for fname, item in cls.__dict__.items():
            if not fname.startswith("_"):
                generate_api(fname, item, cls.__name__)
        if not is_namespace(cls):
            #Checks and casts
            downcast_test = f"{PREFIX}_CanDownCastTo{name}"
            print(f"bool {downcast_test}({REF} ref);")
            print(f"int {PREFIX}_{name}_IsError({TYPED_REF(name)} ref);")
            print(f"{REF} {PREFIX}_{name}_UpCast({TYPED_REF(name)} ref);")
            print(f"{TYPED_REF(name)} _{PREFIX}_{name}_UnsafeDownCast({REF} ref);")
            print(f"""
#define {PREFIX}_{name}_SAFE_DOWNCAST(REF, VAR) \\
if ({downcast_test}(REF)) {{\\
    {TYPED_REF(name)} VAR = _{PREFIX}_{name}_UnsafeDownCast(REF);
    """)
    print()

generate_module(objects)
generate_module(vm)
generate_module(types_and_modules)
